(* An example of a network where we split a budget across two domains. *)

type attribute = option[int]
   
let nodes = 9
   
let edges = {
  0=1;
  1=2;
  0=2;
  2=3;
  1=4;
  3=4;
  5=6;
  6=7;
  7=8;
  2=5;
  3=5;
  3=8;
}

symbolic budget1 : int
symbolic budget2 : int
require (budget1 + budget2) = 10

let init n = match n with
  | 0n -> Some 0
  | _ -> None

let cost edge = match edge with
  | 1~2 -> 3
  | 0~2 -> 2
  | 1~4 -> 2
  | 2~3 -> 3
  | 2~1 -> 3
  | 2~0 -> 2
  | 4~1 -> 2
  | 3~2 -> 3
  | _ -> 1

let trans edge x = match x with
| None -> None
| Some c -> Some (c + (cost edge))

let merge node x y = match (x,y) with
  | (_, None) -> x
  | (None, _) -> y
  | (Some a, Some b) ->
    if a < b then x else y

let sol = solution { init = init; trans = trans; merge = merge }

(* If o is Some, call f with o to return a new option.
   If o is None, return None. Works like OCaml's bind. *)
let bind o f = match o with
  | Some x -> (f x)
  | None -> None

let max x y = if x < y then y else x

let sumDomain1 sol = bind (sol[0n]) (fun c0 -> bind (sol[1n]) 
  (fun c1 -> bind (sol[2n]) (fun c2 -> bind (sol[3n]) (fun c3 -> bind (sol[4n]) 
          (fun c4 -> Some (max c0 (max c1 (max c2 (max c3 c4)))))))))

let sumDomain2 sol = bind (sol[5n]) (fun c5 -> bind (sol[6n]) 
  (fun c6 -> bind (sol[7n]) (fun c7 -> bind (sol[8n])
    (fun c8 -> Some (max c5 (max c6 (max c7 c8)))))))

assert (match sumDomain1 sol with
  | Some c1 -> c1 <= budget1
  | None -> false)
assert (match sumDomain2 sol with
    | Some c2 -> c2 <= budget2
    | None -> false)