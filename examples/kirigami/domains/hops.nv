(* A network where we want to ensure that the 
   total number of hops is beneath some threshold. *)

type attribute = (int, bool)

let pred_t x = true
let pred_a x = let (i, b) = x in i < 3 && b
let pred_b x = let (i, b) = x in i < 3 || b
let pred_c x = let (i, b) = x in i < 4 && b
let pred_d x = let (i, b) = x in b
let pred_e x = let (i, b) = x in i < 4

(* External information from outside the network. *)
symbolic ext : (int, bool)
require (let (i, b) = ext in i > 2 && !b)

(* A waypoint node that must be on each node's shortest path. *)
symbolic waypoint : tnode
require (waypoint = 1n)

let nodes = 6

let edges = {
  0=1;
  1=2;
  2=3;
  0=2;
  3=4;
  1=4;
  5-3;
}

let init node = match node with
  | 0n -> (0, node = waypoint)
  | 1n -> (16, node = waypoint)
  | 2n -> (16, node = waypoint)
  | 3n -> (16, node = waypoint)
  | 4n -> (16, node = waypoint)
  | 5n -> ext

(* The cost associated with a particular edge. *)
let cost edge = match edge with
  | 0~1 -> 1
  | 1~0 -> 1
  | 1~2 -> 3
  | 2~1 -> 3
  | 0~2 -> 2
  | 2~0 -> 2
  | 2~3 -> 3
  | 3~2 -> 3
  | 3~4 -> 1
  | 4~3 -> 1
  | 1~4 -> 1
  | 4~1 -> 1
  | 5~3 -> 0

let trans edge x = let (i, b) = x in (i + (cost edge), b)

(* merge keeps the shorter of the two routes.
 * We want to track if the shorter route is via the waypoint or not.
 *)
let merge node x y =
  let (ix, bx) = x in
  let (iy, by) = y in
  if ix < iy then (ix, bx || (node = waypoint)) else (iy, by || (node = waypoint))

let assert node x = match node with
  | 5n -> true
  | 0n -> let (i, b) = x in i = 0
  | _ -> pred_e x
