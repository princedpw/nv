(* A network that avoids a bad node. *)

type bgp = { lp: int; aslen: int; comms: set[int]}
type attribute = option[bgp]

let nodes = 7
(* 
    1    4
  /  \  / \
  0    3    6
  \  / \  /
   2 -- 5
  
  We want to avoid node 3 and route through other nodes.
  Node 3 should not have a path to the destination, and
  everyone else should.
*)
let edges = {
  0=1;
  0=2;
  1=3;
  2=3;
  2=5;
  3=4;
  3=5;
  4=6;
  5=6;
}

let init node = match node with
| 0n -> Some { lp = 100; aslen = 0; comms = {}}
| _ -> None

let trans edge x =
  match edge with
  | 1~3 -> None
  | 2~3 -> None
  | 4~3 -> None
  | 5~3 -> None
  | _ -> (match x with
  | Some bgp -> Some { lp = bgp.lp; aslen = bgp.aslen + 1; comms = bgp.comms }
  | None -> None)

let transDislike edge x =
  let out3 x = match x with
  | Some bgp -> Some { lp = 50; aslen = bgp.aslen + 1; comms = bgp.comms }
  | None -> None
  in match edge with
  | 3~1 -> out3 x
  | 3~2 -> out3 x
  | 3~4 -> out3 x
  | 3~5 -> out3 x
  | _ -> (match x with
    | Some bgp -> Some { lp = bgp.lp; aslen = bgp.aslen + 1; comms = bgp.comms }
    | None -> None)

let bestBgp b1 b2 = if (b1.lp > b2.lp) || (b1.lp = b2.lp && b1.aslen < b2.aslen) then b1 else b2

let merge node x y = match (x, y) with
  | (None, _) -> y
  | (_, None) -> x
  | (Some b1, Some b2) -> Some (bestBgp b1 b2)

let assertLen x len =
  match (x, len) with
  | (None, None) -> true
  | (None, _) -> false
  | (_, None) -> false
  | (Some b, Some l) -> b.aslen <= l

let assert node x = match node with
  | 0n -> assertLen x (Some 0)
  | 1n -> assertLen x (Some 1)
  | 2n -> assertLen x (Some 1)
  | 3n -> assertLen x None
  | 4n -> assertLen x (Some 4)
  | 5n -> assertLen x (Some 2)
  | 6n -> assertLen x (Some 3)

let partition node = match node with
  | 4n -> 1u8
  | 6n -> 1u8
  | _ -> 0u8

let interface edge = 
  let route a l lp = match a with
    | Some b -> b.aslen <= l && (match lp with
      | Some p -> b.lp = p
      | None -> true)
    | None -> false
  in match edge with
  | 3~4 -> Some (fun a -> a = None)
  | 5~6 -> Some (fun a -> route a 2 (Some 100))
  | 4~3 -> Some (fun a -> route a 4 (Some 100))
  | 6~5 -> Some (fun a -> route a 3 (Some 100))
  | _ -> None